# backtester/research/run_stage_a.py
# CLI entry-point for Stage A: Aggregation & Stability Analysis

from __future__ import annotations

import argparse
import sys
from pathlib import Path
from typing import Optional

from .window_aggregator import DEFAULT_SPLITS
from .strategy_stability import generate_stability_table_from_portfolio_trades
from ..audit.run_audit import audit_run


def format_summary(stability_df) -> str:
    """
    Форматирует краткий summary для вывода в консоль.
    
    :param stability_df: DataFrame с таблицей устойчивости.
    :return: Форматированная строка.
    """
    if len(stability_df) == 0:
        return "No strategies found."
    
    lines = ["\n" + "="*80]
    lines.append("Strategy Stability Summary")
    lines.append("="*80)
    
    # Проверяем наличие колонки split_count
    has_split_count = "split_count" in stability_df.columns
    
    if has_split_count:
        lines.append(f"{'Strategy':<25} {'Split':<8} {'Survival':<10} {'Worst':<12} {'Variance':<12}")
        lines.append("-"*80)
        
        for _, row in stability_df.iterrows():
            strategy = str(row["strategy"])[:23]
            split_count = str(row["split_count"])
            survival = f"{row['survival_rate']:.1%}"
            worst = f"{row['worst_window_pnl']:.4f}"
            variance = f"{row['pnl_variance']:.6f}"
            
            lines.append(f"{strategy:<25} {split_count:<8} {survival:<10} {worst:<12} {variance:<12}")
    else:
        lines.append(f"{'Strategy':<30} {'Survival':<10} {'Worst':<12} {'Variance':<12}")
        lines.append("-"*80)
        
        for _, row in stability_df.iterrows():
            strategy = str(row["strategy"])[:28]
            survival = f"{row['survival_rate']:.1%}"
            worst = f"{row['worst_window_pnl']:.4f}"
            variance = f"{row['pnl_variance']:.6f}"
            
            lines.append(f"{strategy:<30} {survival:<10} {worst:<12} {variance:<12}")
    
    lines.append("="*80)
    lines.append("")
    
    return "\n".join(lines)


def main():
    """
    Точка входа для запуска этапа A.
    
    Stage A работает на portfolio trades (executed), а не на strategy-level trades.
    Использует portfolio_trades.csv - единый файл со всеми исполненными портфельными сделками.
    """
    parser = argparse.ArgumentParser(
        description="Stage A: Aggregation & Stability Analysis (uses portfolio executed trades)"
    )
    
    parser.add_argument(
        "--trades",
        type=str,
        default=None,
        help="Path to portfolio_positions.csv file (positions-level, executed positions). "
             "If not provided, looks for portfolio_positions.csv in --reports-dir",
    )
    
    parser.add_argument(
        "--reports-dir",
        type=str,
        default="output/reports",
        help="Directory for output files and fallback search for portfolio_trades.csv",
    )
    
    parser.add_argument(
        "--splits",
        type=int,
        nargs="+",
        default=None,
        help=f"List of split counts for equal window analysis (e.g., --splits 2 3 4 5). "
             f"If not provided, uses default splits: {DEFAULT_SPLITS}.",
    )
    
    args = parser.parse_args()
    
    reports_dir = Path(args.reports_dir)
    p0_count, _ = audit_run(reports_dir)
    if p0_count > 0:
        print("ERROR: Audit P0 anomalies detected. Stage A blocked.")
        sys.exit(2)
    
    # Определяем путь к portfolio_positions.csv
    if args.trades:
        trades_path = Path(args.trades)
    else:
        trades_path = reports_dir / "portfolio_positions.csv"
    
    if not trades_path.exists():
        print(f"ERROR: Portfolio positions file not found: {trades_path}")
        print(f"       Stage A requires portfolio_positions.csv with executed positions.")
        print(f"       This file should be generated by Reporter.save_portfolio_positions_table()")
        print(f"       Make sure you run main.py first to generate portfolio_positions.csv in --reports-dir")
        sys.exit(1)
    
    # Валидация формата файла (должен быть positions-level, не executions-level)
    try:
        import pandas as pd
        df_sample = pd.read_csv(trades_path, nrows=1)
        
        # ВАЖНО: Сначала проверяем на executions-level по event_type (раньше всего)
        cols = set(df_sample.columns)
        if "event_type" in cols:
            print(f"ERROR: Detected executions-level CSV (column 'event_type' found). Stage A requires positions-level CSV (portfolio_positions.csv).")
            sys.exit(1)
        
        # Только потом проверяем обязательные колонки для positions-level
        required_columns = ["strategy", "signal_id", "entry_time", "exit_time", "status"]
        missing_columns = [col for col in required_columns if col not in df_sample.columns]
        
        if missing_columns:
            print(f"ERROR: Invalid positions file format. Missing required columns: {missing_columns}")
            print(f"       Stage A requires positions-level CSV with columns: {required_columns}")
            print(f"       Make sure you're using portfolio_positions.csv, not portfolio_executions.csv")
            sys.exit(1)
        
        # Проверка наличия обязательных колонок для анализа
        analysis_columns = ["pnl_sol", "pnl_pct", "closed_by_reset"]
        missing_analysis = [col for col in analysis_columns if col not in df_sample.columns]
        if missing_analysis:
            print(f"WARNING: Missing analysis columns: {missing_analysis}. Stage A may not work correctly.")
            print(f"         Required for stability analysis: pnl_sol or pnl_pct, closed_by_reset")
        
    except Exception as e:
        print(f"WARNING: Could not validate file format: {e}")
        print(f"         Continuing anyway, but Stage A may fail if format is incorrect.")
    
    if not reports_dir.exists():
        reports_dir.mkdir(parents=True, exist_ok=True)
    
    print(f"Stage A: Aggregation & Stability Analysis")
    print(f"Portfolio positions file: {trades_path}")
    print(f"Reports directory: {reports_dir}")
    
    # Определяем splits для использования
    splits = args.splits if args.splits is not None else DEFAULT_SPLITS
    print(f"Split counts: {splits}")
    print("")
    
    # Генерируем таблицу устойчивости
    try:
        stability_df = generate_stability_table_from_portfolio_trades(
            trades_path=trades_path,
            reports_dir=reports_dir,
            split_counts=splits,
        )
        
        # Печатаем summary
        summary = format_summary(stability_df)
        print(summary)
        
        print(f"OK: Stage A completed successfully!")
        print(f"Stability table saved to: {reports_dir / 'strategy_stability.csv'}")
        print(f"Detailed windows table saved to: {reports_dir / 'stage_a_summary.csv'}")
        
    except Exception as e:
        print(f"ERROR: Error during Stage A: {e}")
        import traceback
        traceback.print_exc()
        raise


if __name__ == "__main__":
    main()







